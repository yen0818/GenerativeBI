import re, os
from typing import Any, Dict, List, Optional, Type, Union
from pydantic import BaseModel, Field
from langchain.chains.llm import LLMChain

from langchain_core.callbacks import (
    CallbackManagerForToolRun,
)
from langchain_core.tools import BaseTool
from langchain_core.callbacks import (
    CallbackManagerForToolRun,
)
from langchain_core.vectorstores.base import VectorStoreRetriever
from langchain_core.prompts import PromptTemplate

from langchain_core.language_models import BaseLanguageModel
from langchain_core.callbacks import (
    AsyncCallbackManagerForToolRun,
    CallbackManagerForToolRun,
)

from langchain_community.vectorstores import FAISS
from langchain_core.tools import tool
from langchain_openai import  AzureOpenAIEmbeddings 
from langchain_core.documents import Document

from const import EMBED_MODEL
from const import FAISS_TEMPLATE_FILE_PATH, TEMPLATE_FILE_PATH

import json

from dotenv import load_dotenv
load_dotenv()

# Initialize the embeddings and FAISS vector store as before
embed_model = AzureOpenAIEmbeddings(deployment=EMBED_MODEL, model=EMBED_MODEL)

# Create or load the FAISS vector store
if os.path.exists(FAISS_TEMPLATE_FILE_PATH):
    faiss_vector_store = FAISS.load_local(FAISS_TEMPLATE_FILE_PATH, embed_model, allow_dangerous_deserialization=True)
else:
    with open(TEMPLATE_FILE_PATH, "r") as file:
        data = json.load(file)
    documents = []
    for chart_name, chart_info in data['charts'].items():
        doc_content = f"Chart Name: {chart_name}\nChart Description: {chart_info['description']}\nCode Template: {chart_info['code']}\nInstructions in generating the chart: {chart_info['instructions']}"
        documents.append(Document(page_content=doc_content))
    for table_name, table_info in data['tables'].items():
        doc_content = f"Table Type: {table_name}\nTable Description: {table_info['description']}\nCode Template: {table_info['code']}"
        documents.append(Document(page_content=doc_content))
    faiss_vector_store = FAISS.from_documents(documents, embed_model)
    faiss_vector_store.save_local(FAISS_TEMPLATE_FILE_PATH)

# Get the VectorStoreRetriever from the FAISS vector store
faiss_vector_store_retriever = faiss_vector_store.as_retriever()


TEMPLATE = """
    You're an AI master at planning and breaking down a coding task into smaller, tractable chunks.
    You will be given a task, please helps us thinking it through, step-by-step.

    First, let's see an example of what we expect:

    Task1: Generate a Python code script to plot the data in a dataframe df.
    Steps:
    1. I should import the necessary libraries: pandas for data manipulation, matplotlib for plotting, and streamlit for web app integration, etc.
    2. I should create a script using the dataframe df to graph the data based on the question asked.
    3. I should remember to label the x and y axes appropriately and add a title.
    4. I should understand certain plots require specific data types, ensure I am using the correct columns for the plot.
    5. I should ensure the plot is displayed using st.plotly_chart() or st.pyplot() or any relevant Streamlit function.

    Task2: Generate a Python code script to display the data in a table format.
    Steps:
    1. I should import the necessary libraries: pandas, numpy, streamlit, io, etc.
    2. I should create a copy of the dataframe df using the dataframe df.copy() before processing the data.
    3. I should not use the print() function to display the dataframe.
    4. I should use st.write() or st.table() to display the dataframe in a table format.

    The things that you should remember when generating the code script:
    - This is the dataframe that you should use: {df} and the columns in the dataframe are: {df_columns}.
    - You should only select the columns instead of dropping the not needed columns. (e.g. df[['column1', 'column2']] but not df.drop(['column3'], axis=1)).
    - You should allow users to ask for customizations and include the necessary customizations in the code generated.
    - You should check the code generated and ensure all the libraries are imported at the beginning of the script.
    - Use backslashes (\) to escape the inner double quotes: st.write("Histogram for \\"radius_mean\\" column").

    For example, this is the code generated by the tool:
    ```python
        import pandas as pd;
        import streamlit as st;
        import matplotlib.pyplot as plt;
        st.write("Histogram for 'radius_mean' column");
        fig, ax = plt.subplots();
        ...
        st.pyplot(fig);
    ```

    ALWAYS remember this is not done yet, you need to make sure you have done the following:
    1. Remove any unnecesary comments from the code.
    2. Ensure semi-colons are included at the end of each line of code.

    You can refer to the code templates and information below to generate the code script, this template is relevant to the task given:
    {code_snippets}
   
    ====== Your Turn =====
    Task: {requirements}
    Python Code Script:
 
    """

class GeneratePlanInput(BaseModel):
    requirements: str = Field(description="The requirements of the task.")

class GeneratePlanTool(BaseTool):
    """Use an LLM to generate a plan for a coding task."""

    name: str = "GeneratePlanTool"
    description: str = "Use this tool to generate a plan for a coding task."
    args_schema: Type[BaseModel] = GeneratePlanInput
    template: str = TEMPLATE
    llm: BaseLanguageModel
    df_columns: List[str]
    df: Any
    return_direct: bool = False

    def __init__(self, 
                 llm: BaseLanguageModel, 
                 df_columns: List[str], 
                 df,
                 **kwargs: Any) -> None:
        super().__init__(llm=llm, df_columns=df_columns, df=df, **kwargs)

    def postprocess(self, response: str) -> str:
        """Postprocess the response."""
        code_block_match = re.search(r'```python(.*?)```', response, re.DOTALL)
        if code_block_match:
            return code_block_match.group(1).strip()
    
    def _run(
        self, requirements: str, run_manager: Optional[CallbackManagerForToolRun] = None
    ) -> str:
        """Use the tool."""
        # Step 1: Retrieve relevant code templates
        retrieved_docs = faiss_vector_store_retriever.invoke(requirements)[:1]
        code_snippets = [doc.page_content for doc in retrieved_docs][0]
        df_columns = self.df_columns
        df = self.df

        # Step 2: Incorporate code templates into the prompt
        prompt = PromptTemplate(
            template=self.template,
            input_variables=["requirements", "code_snippets", "df", "df_columns"]
        )

        # Step 3: Create the LLM chain and generate the output
        chain = LLMChain(
            llm=self.llm,
            prompt=prompt
        )
        out = chain.predict(
            requirements=requirements,
            code_snippets=code_snippets,
            df_columns=df_columns,
            df=df,
            callbacks=run_manager.get_child() if run_manager else None
        )
        return self.postprocess(out)

    async def _arun(
        self,
        requirements: str,
        df_columns: List[str],
        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,
    ) -> str:
        """Use the tool asynchronously."""
        # Step 1: Retrieve relevant code templates
        retrieved_docs = await faiss_vector_store_retriever.aget_relevant_documents(requirements)
        code_snippets = "\n\n".join([doc.page_content for doc in retrieved_docs])
        df_columns = self.df_columns
        df = self.df

        # Step 2: Incorporate code templates into the prompt
        prompt = PromptTemplate(
            template=self.template,
            input_variables=["requirements", "code_snippets", "df", "df_columns"]
        )

        # Step 3: Create the LLM chain and generate the output
        chain = LLMChain(
            llm=self.llm,
            prompt=prompt
        )
        out = await chain.apredict(
            requirements=requirements,
            code_snippets=code_snippets,
            df_columns=df_columns,
            df=df,
            callbacks=run_manager.get_child() if run_manager else None
        )
        return self.postprocess(out)